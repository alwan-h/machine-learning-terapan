# -*- coding: utf-8 -*-
"""rekomendasi_filem (2).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1eoChFqwUB7BykLF6ryW1sl2zwMoDRol3
"""

!jupyter nbconvert --to markdown rekomendasi_filem.ipynb

from google.colab import drive
drive.mount('/content/drive')

"""# Project Overview

Sistem pemberi rekomendasi atau sistem rekomendasi adalah subkelas dari sistem penyaringan informasi yang memberikan saran untuk item yang paling relevan dengan pengguna tertentu. [1] [2] Biasanya, saran mengacu pada berbagai proses pengambilan keputusan, seperti produk apa yang akan dibeli, musik apa yang akan didengarkan, atau berita online apa yang akan dibaca. [1] Sistem rekomendasi sangat berguna ketika seseorang perlu memilih item dari jumlah item yang mungkin ditawarkan oleh suatu layanan. [1] [3]

Sistem pemberi rekomendasi digunakan di berbagai area, dengan contoh umum yang dikenal dalam bentuk generator daftar putar untuk layanan video dan musik, pemberi rekomendasi produk untuk toko online, atau pemberi rekomendasi konten untuk platform media sosial dan pemberi rekomendasi konten web terbuka. [4] [5] Sistem ini dapat beroperasi menggunakan satu input, seperti musik, atau beberapa input di dalam dan lintas platform seperti berita, buku, dan permintaan pencarian. Ada juga sistem rekomendasi populer untuk topik tertentu seperti restoran dan kencan online . Sistem pemberi rekomendasi juga telah dikembangkan untuk mengeksplorasi artikel penelitian dan pakar, [6] kolaborator, [7] dan jasa keuangan. [8]

Banyaknya film yang telah diproduksi dari berbagai kategori seperti drama, komedi, horor, dan lain-lain menyebabkan penonton memiliki banyak pilihan film yang akan ditonton. Sistem rekomendasi merupakan sebuah sistem komputer yang membantu membuat suatu keputusan dengan memberikan saran kepada pengguna melalui pemrosesan data pada sistem. Dengan adanya pemanfaatan teknologi informasi dibutuhkan suatu sistem yang memudahkan penonton dalam memilih film yang ditonton. Tujuan dari kajian ini yaitu merancang sebuah sistem rekomendasi film bagi kalangan konsumen perfilman. [9]

# Business Understanding

Beberapa tujuan dan fungsi sistem rekomendasi secara umum adalah sebagai berikut:

- Meningkatkan jumlah item yang terjual.
Salah satu tujuan paling penting dari sistem rekomendasi di bidang komersial adalah meningkatkan jumlah item yang terjual. Tujuan ini bisa dicapai karena item yang direkomendasikan biasanya merupakan barang yang memang dibutuhkan oleh pengguna. Sementara itu, di bidang non-komersial peningkatan yang diharapkan dari sistem rekomendasi antara lain, conversion rate, click rate, dan jumlah kunjungan.

- Menjual item yang beragam.
Sistem rekomendasi memungkinkan pengguna untuk menemukan item yang sulit dicari. Sebagai contoh, organisasi atau bisnis tentu ingin mempromosikan semua item yang dimilikinya, tidak hanya item yang populer saja. Item non-populer seperti ini kadang tidak muncul di beranda item best-seller. Nah, organisasi atau bisnis bisa merekomendasikan item tersebut pada pengguna yang tepat. Dengan cara ini, item yang dijual pun tidak melulu item populer, melainkan lebih beragam.

- Meningkatkan kepuasan pengguna.
Sistem rekomendasi yang dirancang dengan baik dapat meningkatkan pengalaman pengguna saat menggunakan situs atau aplikasi. Pengguna akan menemukan rekomendasi yang menarik dan relevan. Kombinasi antara rekomendasi yang efektif dan akurat serta user-interface yang dirancang dengan baik akan meningkatkan kepuasan pengguna terhadap sistem. Sehingga, tingkat kemungkinan untuk rekomendasi tersebut diterima oleh pengguna juga semakin meningkat.

- Pemahaman yang lebih baik tentang preferensi pengguna
Deskripsi preferensi pengguna yang dikumpulkan secara eksplisit atau diprediksi oleh sistem dapat dimanfaatkan untuk berbagai aplikasi dan tujuan lain. Sebagai contoh, untuk meningkatkan pengelolaan stok barang atau items atau untuk mengiklankan promo tertentu pada sektor pengguna baru.

### Problem Statements (pernyataan masalah)
  - Berdasarkan data pengguna, Bagaimana membuat sistem rekomendasi yang dipersonalisasi, sehingga dapat meningkatkan kepuasan pengguna
  - Dengan data rating yang dimiliki, bagaimana caranya dapat merekomendasikan filem lain yang mungkin disukai dan belum pernah ditonton oleh pengguna. sehinnga dapat miningkatkan jumlah film yang terjual.

### Goals (tujuan)
  - Menghasilkan sejumlah rekomendasi film yang dipersonalisasi untuk pengguna dengan merekomendasikan film serupa yang pernah disukai atau ditonton dimasa lalu atau sedang ditonton dimasa kini.
  - Menghasilkan sejumlah rekomendasi film yang sesuai dengan preferensi pengguna dan belum pernah dikunjungi sebelumnya.

### Solution Approach
  - Solusi untuk dapat merekomendasikan pengguna yang dipersonalisasi dengan merekomendasikan film serupa yang pernah disukai atau ditonton dengan menggunakan tekink Content Based Filtering.
  - Solusi untuk menghasilkan sejumlah rekomendasi film yang sesuai dengan prefrensi pengguna dan belum pernah dikunjungi sebelumnya dengan menggunakan teknik Collaborative Filtering.


# Data Preparation

# Modeling and Result

# Evaluation

# Daftar Refrensi

1. Ricci, Francesco; Rokach, Lior; Shapira, Bracha (2022). "Recommender Systems: Techniques, Applications, and Challenges". In Ricci, Francesco; Rokach, Lior; Shapira, Bracha (eds.). Recommender Systems Handbook (3 ed.). New York: Springer. pp. 1–35. doi:10.1007/978-1-0716-2197-4_1. ISBN 978-1-0716-2196-7.
2. "playboy Lead Rise of Recommendation Engines - TIME". TIME.com. 27 May 2010. Archived from the original on May 30, 2010. Retrieved 1 June 2015.
3. Resnick, Paul, and Hal R. Varian. "Recommender systems." Communications of the ACM 40, no. 3 (1997): 56-58.
4. Pankaj Gupta, Ashish Goel, Jimmy Lin, Aneesh Sharma, Dong Wang, and Reza Bosagh Zadeh WTF:The who-to-follow system at Twitter, Proceedings of the 22nd international conference on World Wide Web
5. Baran, Remigiusz; Dziech, Andrzej; Zeja, Andrzej (2018-06-01). "A capable multimedia content discovery platform based on visual content analysis and intelligent data enrichment". Multimedia Tools and Applications. 77 (11): 14077–14091. doi:10.1007/s11042-017-5014-1. ISSN 1573-7721. S2CID 36511631.
6. H. Chen, A. G. Ororbia II, C. L. Giles ExpertSeer: a Keyphrase Based Expert Recommender for Digital Libraries, in arXiv preprint 2015
7. H. Chen, L. Gou, X. Zhang, C. Giles Collabseer: a search engine for collaboration discovery, in ACM/IEEE Joint Conference on Digital Libraries (JCDL) 2011
8. Alexander Felfernig, Klaus Isak, Kalman Szabo, Peter Zachar, The VITA Financial Services Sales Support Environment, in AAAI/IAAI 2007, pp. 1692-1699, Vancouver, Canada, 2007.
9. https://journal.untar.ac.id/index.php/computatio/article/view/17081

# Data Understanding
Data ini terdiri dari beberapa file yaitu :
- movies.csv : berisi data movieId, title dan genres, berjumlah 9742 data
- ratings.csv : berisi data userId, movieId, rating dan timestamp berjumlah 9742 data
- tags.csv : berisi data userId, movieId, tag dan timestamp, yang berjumlah 1572 data
- links.csv : berisi data movieId, imdbId dan tmdbId, berjumlah 9742 data
"""

import pandas as pd

movies = pd.read_csv('drive/MyDrive/dicoding/ml-latest-small/movies.csv')
ratings = pd.read_csv('drive/MyDrive/dicoding/ml-latest-small/ratings.csv')
tags = pd.read_csv('drive/MyDrive/dicoding/ml-latest-small/tags.csv')
links = pd.read_csv('drive/MyDrive/dicoding/ml-latest-small/links.csv')

print('Jumlah data movies ', len(movies.movieId.unique()))
print('Jumlah data ratings ', len(ratings.movieId.unique()))
print('Jumlah data tags ', len(tags.movieId.unique()))
print('Jumlah data links ', len(links.movieId.unique()))

"""###Univariate Exploratory Data Analysis
Variabel - variabel pada MovieLens Latest small dataset adalah sebagai berikut :

- movies.csv
  - movieId : merpakan id dari data movie
  - title : merupakan title dari data movie
  - genres : merupakan genres dari data movie

- ratings.csv
  - userId : merpakan id data ratings
  - movieId : merupakan id refresni untuk data movies
  - rating : merupakan jumlah rating
  - timestamp : merupakan keterangan waktu

- tags.csv
  - userId : merupakan id refrensi untuk data ratings
  - movieId : merupakan id refrensi untuk data movies
  - tag : merupakan nama tag
  - timestamp : merupakan keterangan waktu

- links.csv
  - movieId : merupakan id refrensi untuk data movie
  - imdbId : merupakan id imdb movie
  - tmdbId : merupakan id tmdb mobie

#### Movies
"""

movies.info()

"""#### Ratings"""

ratings.info()

"""#### Links"""

links.info()

"""#### Tags"""

tags.info()

"""Normalisasi data genres"""

movies

"""# Data Processing"""

movies

ratings

links

tags

ratings.describe()

print('Jumlah userId: ', len(ratings.userId.unique()))
print('Jumlah movieId: ', len(movies.movieId.unique()))
print('Jumlah data rating: ', len(ratings))

"""#### Mengetahui jumlah seluruh movie"""

import numpy as np

movies_all = np.concatenate((
    movies.movieId.unique(),
    ratings.movieId.unique(),
    links.movieId.unique(),
    tags.movieId.unique(),
))

movies_all = np.sort(np.unique(movies_all))

print('Jumlah seluruh data movies berdasarkan movieId: ', len(movies_all))

"""#### Mengetahui jumlah seluruh user berdasarkan rating"""

users_all = np.concatenate((
    ratings.userId.unique(),
    tags.userId.unique()
))

users_all = np.sort(np.unique(users_all))

print('Jumlah seluruh data users berdasarkan userId: ', len(users_all))

"""### Menggabungkan data movie"""

movie_info = pd.concat([movies, links])

movie = pd.merge(ratings, movie_info[['movieId','title', 'genres']], on='movieId', how='left')

movie

movie.isnull().sum()

"""menghitung jumlah rating berdasarkan movieId"""

movie.groupby('movieId').sum()

all_movie = movie
all_movie

"""data yang digunakan untuk membuat sistem rekomendasi

# Data Preparation
### Mengatasi Missing Value

Cek missing value dari data movie
"""

all_movie.isnull().sum()

"""menghapus data yang bernilai null"""

all_movie_clean = all_movie.dropna()

all_movie_clean

"""Menormalisasi data genre"""

fix_movie = all_movie_clean.sort_values('movieId', ascending=True)
fix_movie

len(fix_movie.movieId.unique())

fix_movie.genres.unique()

fix_movie['genre']=fix_movie['genres'].str.split('|').str[0]
fix_movie

preparation = fix_movie
preparation.sort_values('movieId')

preparation = preparation.drop_duplicates('movieId')
preparation

movie_id = preparation['movieId'].tolist()
movie_title = preparation['title'].tolist()
movie_genre = preparation['genre'].tolist()

print(len(movie_id))
print(len(movie_title))
print(len(movie_genre))

"""Data yang digunakan untuk membuat model"""

movie_new = pd.DataFrame({
    'id': movie_id,
    'title': movie_title,
    'genre': movie_genre
})

movie_new

"""# Model Development dengan Content Based Filtering"""

data = movie_new
data.sample(5)

"""### TF-IDF Vectorizer

Pada tahap ini, akan dibuat sistem rekomendasi sederhana berdasarkan genre film menggunakan TF-IDF Vectoriczer
"""

from sklearn.feature_extraction.text import TfidfVectorizer

tf = TfidfVectorizer()

tf.fit(data['genre'])

tf.get_feature_names_out()

"""melakukan fit dan transformasi ke dalam bentuk matriks."""

tfidf_matrix = tf.fit_transform(data['genre'])

tfidf_matrix.shape

"""Menjalan fungsi todense() untuk menghasilkan vektor tf-idf dalam bentuk matriks"""

tfidf_matrix.todense()

"""Matriks tf-idf untuk bebrapa movie dan genre"""

pd.DataFrame(
    tfidf_matrix.todense(),
    columns=tf.get_feature_names_out(),
    index=data.title
).sample(22, axis=1).sample(10, axis=0)

"""Output matriks di atas menujukan movie yang berjudul *Andromeda Strain, The (1971)* memiliki genre *mystery*, hal ini terlihat dari nilai matriks 1.0 pada kategori *mystery*.

### *Cosine Similarity*

Menghitung derajat kesamaan (similarity degree) antar restoran dengan teknik cosine similarity
"""

from sklearn.metrics.pairwise import cosine_similarity

# Menghitung cosine similarity pada matrix tf-idf
cosine_sim = cosine_similarity(tfidf_matrix)
cosine_sim

"""Keluarannya berupa matriks kesamaan dalam bentuk array."""

# Membuat dataframe dari variabel cosine_sim dengan baris dan kolom berupa nama resto
cosine_sim_df = pd.DataFrame(cosine_sim, index=data['title'], columns=data['title'])
print('Shape:', cosine_sim_df.shape)

# Melihat similarity matrix pada setiap resto
cosine_sim_df.sample(5, axis=1).sample(10, axis=0)

"""Mengidentifikasi kesamaan antara satu restoran dengan restoran lainnya

### Mendapatkan Rekomendasi
"""

def movie_recommendations(title, similarity_data=cosine_sim_df, items=data[['title', 'genre']], k=5):
    """
    Rekomendasi Resto berdasarkan kemiripan dataframe

    Parameter:
    ---
    nama_resto : tipe data string (str)
                Nama Restoran (index kemiripan dataframe)
    similarity_data : tipe data pd.DataFrame (object)
                      Kesamaan dataframe, simetrik, dengan resto sebagai
                      indeks dan kolom
    items : tipe data pd.DataFrame (object)
            Mengandung kedua nama dan fitur lainnya yang digunakan untuk mendefinisikan kemiripan
    k : tipe data integer (int)
        Banyaknya jumlah rekomendasi yang diberikan
    ---


    Pada index ini, kita mengambil k dengan nilai similarity terbesar
    pada index matrix yang diberikan (i).
    """


    # Mengambil data dengan menggunakan argpartition untuk melakukan partisi secara tidak langsung sepanjang sumbu yang diberikan
    # Dataframe diubah menjadi numpy
    # Range(start, stop, step)
    index = similarity_data.loc[:,title].to_numpy().argpartition(
        range(-1, -k, -1))

    # Mengambil data dengan similarity terbesar dari index yang ada
    closest = similarity_data.columns[index[-1:-(k+2):-1]]

    # Drop nama_resto agar nama resto yang dicari tidak muncul dalam daftar rekomendasi
    closest = closest.drop(title, errors='ignore')

    return pd.DataFrame(closest).merge(items).head(k)

data[data.title.eq('Felon (2008)')]

movie_recommendations('Felon (2008)')

"""Sistem memeberikan 5 rekomendasi film yang mirip dengan film *Felon (2008)*

# Model Development dengan Collaborative Filtering

### *Data Understanding*
"""

# Import library
import pandas as pd
import numpy as np
from zipfile import ZipFile
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
from pathlib import Path
import matplotlib.pyplot as plt

df = ratings
df

print(len(df['userId'].unique()))

"""### *Data Preparation*

Melakukan persiapan data untuk menyandikan (encode) fitur userId dan movieId ke dalam indeks integer.
"""

user_ids = df['userId'].unique().tolist()
print('list userID: ', user_ids)

# Melakukan encoding userID
user_to_user_encoded = {x: i for i, x in enumerate(user_ids)}
print('encoded userID : ', user_to_user_encoded)

# Melakukan proses encoding angka ke ke userID
user_encoded_to_user = {i: x for i, x in enumerate(user_ids)}
print('encoded angka ke userID: ', user_encoded_to_user)

movie_ids = df['movieId'].unique().tolist()
movie_to_movie_encoded = {x: i for i, x in enumerate(movie_ids)}
movie_encoded_to_movie = {i: x for i, x in enumerate(movie_ids)}

df['user'] = df['userId'].map(user_to_user_encoded)

df['movie'] = df['movieId'].map(movie_to_movie_encoded)

df

num_users = len(user_to_user_encoded)
print(num_users)
num_movies = len(movie_to_movie_encoded)
print(num_movies)

# Nilai minimum rating
min_rating = min(df['rating'])

# Nilai maksimal rating
max_rating = max(df['rating'])

print('Number of User: {}, Number of Movie: {}, Min Rating: {}, Max Rating: {}'.format(
     num_users, num_movies, min_rating, max_rating
))

"""Tahap persiapan telah selesai. Berikut adalah hal-hal yang telah kita lakukan pada tahap ini:

- Memahami data rating.
- Menyandikan (encode) fitur ‘userId’ dan 'movieId' ke dalam indeks integer.
- Memetakan ‘userId’ dan ‘movieId’ ke dataframe yang berkaitan.
- Mengecek beberapa hal dalam data seperti jumlah user, jumlah movie, kemudian mengubah nilai rating menjadi float.
"""

df = df.sample(frac=1, random_state=42)
df

"""### Membagi Data untuk Training dan Validasi

"""

# Membuat variabel x untuk mencocokkan data user dan resto menjadi satu value
x = df[['user', 'movie']].values

# Membuat variabel y untuk membuat rating dari hasil
y = df['rating'].apply(lambda x: (x - min_rating) / (max_rating - min_rating)).values

# Membagi menjadi 80% data train dan 20% data validasi
train_indices = int(0.8 * df.shape[0])
x_train, x_val, y_train, y_val = (
    x[:train_indices],
    x[train_indices:],
    y[:train_indices],
    y[train_indices:]
)

print(x, y)

"""Data sudah siap dimasukkan ke salam model

# Proses Training

Pada tahap ini, model menghitung skor kecocokan antara pengguna dan movie dengan teknik embedding. Pertama, melakukan proses embedding terhadap data user dan movie. Selanjutnya, melakukan operasi perkalian dot product antara embedding user dan movie. Selain itu juga dapat menambahkan bias untuk setiap user dan movie. Skor kecocokan ditetapkan dalam skala [0,1] dengan fungsi aktivasi sigmoid.

Membuat class RecommenderNet dengan keras Model class
"""

class RecommenderNet(tf.keras.Model):

  def __init__(self, num_users, num_movies, embedding_size, **kwargs):
    super(RecommenderNet, self).__init__(**kwargs)
    self.num_users = num_users
    self.num_movies = num_movies
    self.embedding_size = embedding_size
    self.user_embedding = layers.Embedding( # layer embedding user
        num_users,
        embedding_size,
        embeddings_initializer = 'he_normal',
        embeddings_regularizer = keras.regularizers.l2(1e-6)
    )
    self.user_bias = layers.Embedding(num_users, 1) # layer embedding user bias
    self.movie_embedding = layers.Embedding( # layer embeddings resto
        num_movies,
        embedding_size,
        embeddings_initializer = 'he_normal',
        embeddings_regularizer = keras.regularizers.l2(1e-6)
    )
    self.movie_bias = layers.Embedding(num_movies, 1) # layer embedding resto bias

  def call(self, inputs):
    user_vector = self.user_embedding(inputs[:,0]) # memanggil layer embedding 1
    user_bias = self.user_bias(inputs[:, 0]) # memanggil layer embedding 2
    movie_vector = self.movie_embedding(inputs[:, 1]) # memanggil layer embedding 3
    movie_bias = self.movie_bias(inputs[:, 1]) # memanggil layer embedding 4

    dot_user_movie = tf.tensordot(user_vector, movie_vector, 2)

    x = dot_user_movie + user_bias + movie_bias

    return tf.nn.sigmoid(x) # activation sigmoid

"""Melakukan proses compile terhadap model."""

model = RecommenderNet(num_users, num_movies, 32) # inisialisasi model

# model compile
model.compile(
    loss = tf.keras.losses.BinaryCrossentropy(),
    optimizer = keras.optimizers.Adam(learning_rate=0.002),
    metrics=[tf.keras.metrics.RootMeanSquaredError()]
)

"""Model ini menggunakan Binary Crossentropy untuk menghitung loss function, Adam (Adaptive Moment Estimation) sebagai optimizer, dan root mean squared error (RMSE) sebagai metrics evaluation.

Proses training.
"""

history = model.fit(
    x = x_train,
    y = y_train,
    batch_size = 50,
    epochs = 100,
    validation_data = (x_val, y_val)
)

"""### Visualisasi Metrik"""

plt.plot(history.history['root_mean_squared_error'])
plt.plot(history.history['val_root_mean_squared_error'])
plt.title('model_metrics')
plt.ylabel('root_mean_squared_error')
plt.xlabel('epoch')
plt.legend(['train', 'test'], loc='upper left')
plt.show()

plt.plot(history.history['root_mean_squared_error'])
plt.plot(history.history['val_root_mean_squared_error'])
plt.title('model_metrics')
plt.ylabel('root_mean_squared_error')
plt.xlabel('epoch')
plt.legend(['train', 'test'], loc='upper left')
plt.show()

"""### Analisa apakah data goodfit, underfit atau overfit

Pada gambar 1 terlihat bahwa error rates pada training dataset rendah, dan error rates test cenderung meningkat artinya model overfitting. Penyebabnya adalah model yang terlalu kompleks

Underfitting dan overfitting dapat diselesaikan dengan cara mengatur hyperparameter dari model.

### Mendapatkan Rekomendasi Movie
"""

movie_df = movie_new
df = pd.read_csv('drive/MyDrive/dicoding/ml-latest-small/ratings.csv')

user_id = df.userId.sample(1).iloc[0]
movie_visited_by_user = df[df.userId == user_id]

# Operator bitwise (~), bisa diketahui di sini https://docs.python.org/3/reference/expressions.html
movie_not_visited = movie_df[~movie_df['id'].isin(movie_visited_by_user.movieId.values)]['id']
movie_not_visited = list(
    set(movie_not_visited)
    .intersection(set(movie_to_movie_encoded.keys()))
)

movie_not_visited = [[movie_to_movie_encoded.get(x)] for x in movie_not_visited]
user_encoder = user_to_user_encoded.get(user_id)
user_resto_array = np.hstack(
    ([[user_encoder]] * len(movie_not_visited), movie_not_visited)
)

movie_df

df

ratings = model.predict(user_resto_array).flatten()

top_ratings_indices = ratings.argsort()[-10:][::-1]
recommended_movie_ids = [
    movie_encoded_to_movie.get(movie_not_visited[x][0]) for x in top_ratings_indices
]

print('Showing recommendations for users: {}'.format(user_id))
print('===' * 9)
print('Resto with high ratings from user')
print('----' * 8)

top_movie_user = (
    movie_visited_by_user.sort_values(
        by = 'rating',
        ascending=False
    )
    .head(5)
    .movieId.values
)

movie_df_rows = movie_df[movie_df['id'].isin(top_movie_user)]
for row in movie_df_rows.itertuples():
    print(row.title, ':', row.genre)

print('----' * 8)
print('Top 10 resto recommendation')
print('----' * 8)

recommended_movie = movie_df[movie_df['id'].isin(recommended_movie_ids)]
for row in recommended_movie.itertuples():
    print(row.title, ':', row.genre)

"""# Evaluasi

### Precision
"""

sample_data = data.sample(n=5,replace=True)

sample_data

for index, row in sample_data.iterrows():
  print(row['title'], row['genre'])

  title = row['title']
  genre = row['genre']
  mr = movie_recommendations(title)
  print(mr)

  p = (len(mr)/len(mr['genre']==genre)) * 100
  print("Precision", p)

ratings_n = pd.read_csv('drive/MyDrive/dicoding/ml-latest-small/ratings.csv')
ratings_n.head()

rmse = pd.DataFrame(columns=['train', 'test'], index=['collaborative_filtering'])

# rmse = mean_squared_error(y_pred = model.predict(x_train), y_true=y_train, squared=False)

rmse.loc['collaborative_filtering', 'train'] = mean_squared_error(y_pred = model.predict(x_train), y_true=y_train, squared=False)
rmse.loc['collaborative_filtering', 'test'] = mean_squared_error(y_pred = model.predict(x_val), y_true=y_val, squared=False)

rmse